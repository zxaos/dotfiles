# Try to determine the current terminal emulator
local pid=$$
# echo "starting pid = $pid"
TERM_EMULATOR_DETECTED='unknown'
while true; do
    # pid=$(ps -h -o ppid -p $pid 2>/dev/null) // this works in linux, but osx has BSD style PS instead
    pid=$(ps -o 'ppid=' -p $pid 2>/dev/null | xargs) # get parent pid and strip whitespace with xargs
    # echo "iterating pid as... as $pid"
    local comm=$(ps -o 'comm=' -p $pid 2>/dev/null | xargs )
    comm=$(basename -- $comm)
    # echo "checking comm as... $comm"
    case "$comm" in
    (iTerm2) TERM_EMULATOR_DETECTED='iTerm2';break;;
    (tmux) TERM_EMULATOR_DETECTED='tmux';break;;
    (alacritty) TERM_EMULATOR_DETECTED='alacritty';break;;
    (Terminal) TERM_EMULATOR_DETECTED='Terminal.app';break;;
    (nvim) TERM_EMULATOR_DETECTED='nvim';break;;
    # (xterm) TERM_EMULATOR_DETECTED='xterm';break;;
    # (rxvt) TERM_EMULATOR_DETECTED='rxvt';break;;
    # (gnome-terminal) TERM_EMULATOR_DETECTED='gnome-terminal';break;;
    # (python) if [ ! -z "$(ps -h -o args -p $pid 2>/dev/null | grep guake)" ]; then TERM_EMULATOR_DETECTED='guake'; break; fi ;;
    esac
    [ "$pid" = 1 ] && break
done
# echo "Running in $TERM_EMULATOR_DETECTED"


# Set up completion styles
zstyle ':completion:*' completer _expand _complete _ignored _match _correct _approximate
zstyle ':completion:*' format 'Completing %d'
zstyle ':completion:*' list-colors ''
zstyle ':completion:*' menu select=long
zstyle ':completion:*' select-prompt %SScrolling active: current selection at %p%s
zstyle :compinstall filename '/Users/matt/.zshrc'

# Load and initialize the completion system ignoring checks of insecure directories but still dumping to cache.
autoload -Uz compinit && compinit -C -d ~/.zcompdump

# Offer to correct misspellings
setopt correct

# Save command history
HISTFILE=~/.histfile
HISTSIZE=1000
SAVEHIST=1000

# Use vim keybindings
bindkey -v

# Allow zsh online help
unalias run-help
autoload run-help
HELPDIR=/usr/local/share/zsh/help

# Enable chruby and auto-switching
source /usr/local/opt/chruby/share/chruby/chruby.sh
source /usr/local/share/chruby/auto.sh

# Enable nodenv and auto-switching
if type nodenv > /dev/null; then
  eval "$(nodenv init -)"
fi;

# Araxis Merge conflicts with ImageMagick if installed ('compare' binary) - prefer araxis.
# This means prepending the Araxis utils directory to PATH before the homebrew directory
# If homebrew is not found, it just gets added to the end of the path
if [ -d "/Applications/Araxis Merge.app/Contents/Utilities" ]; then
  local brew_path_index
	local brew_path
	brew_path_index=$path[(i)/usr/local/bin]
	brew_path=$path[$brew_path_index]
	path[brew_path_index]=( "/Applications/Araxis Merge.app/Contents/Utilities" $brew_path )
fi

# Allow user-local libraries in system python and ruby packages
path+=("$HOME/Library/Python/2.7/bin")
path+=("$HOME/.gem/ruby/2.0.0/bin")
export PATH

# Enable antibody zsh package manager
source <(antibody init)
if type antibody > /dev/null && [ -f ~/.zsh-antibody-plugins ]; then
  source ~/.zsh-antibody-plugins
else
  echo "WARNING: PLUGINS NOT LOADED"
fi

[ -f ~/.fzf.zsh ] && source ~/.fzf.zsh

export XDG_CONFIG_HOME=~/.config
export XDG_CACHE_HOME=~/.cache.
export XDG_DATA_HOME=~/.local/share
export XDG_RUNTIME_DIR=$TMPDIR

export TMUX_TMPDIR="$XDG_RUNTIME_DIR"

export CLICOLOR=1

if type "nvim" > /dev/null; then
  alias vim='nvim'
fi

if [ $TERM_EMULATOR_DETECTED = 'iTerm2' ]; then
  # Enable iterm2 integration
  test -e "${HOME}/.iterm2_shell_integration.zsh" && source "${HOME}/.iterm2_shell_integration.zsh"

  function it2prof() { echo -e "\e]1337;SetProfile=$1\07" }

  # Aliases
  #function _nvim(){ # Set vim profile, run vim, set Nova profile on exit
  #  it2prof vim
  #  nvim "$@"
  #  it2prof Nova
  #}
  #alias nvim='_nvim'

fi
